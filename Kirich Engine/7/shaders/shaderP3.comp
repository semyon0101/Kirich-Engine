#version 450

struct Particle {
	vec2 position;
    vec2 lposition;
};

layout (set = 0, binding = 0) uniform ParameterUBO {
    int division;
    int width;
    int height;
} ubo;

layout(std140, set = 1, binding = 0) readonly buffer ParticleSSBOIn {
   Particle particlesIn[ ];
};

layout(std140, set = 1, binding = 1) buffer ParticleSSBOOut {
   Particle particlesOut[ ];
};

layout(set = 1, binding = 2) readonly buffer ParticleData {
    uint data[ ];
};


layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
void main() 
{
    uint id = gl_GlobalInvocationID.x;  
    ivec2 location =  ivec2(round(particlesIn[id].position));
//    if (data[location.x * ubo.height / ubo.division + location.y] != id + 1){
//        particlesOut[id].position = vec2(0,0);
//    }

    float e = 1;
    float s = 1.8;
    float m = 1;
    vec2 F = vec2(0, 0);
    vec2 a = vec2(0, 0);
    for(int x=-5; x<=5; ++x){
        for(int y=-5; y<=5; ++y){
            if(x==0 && y==0) continue;
            ivec2 pos = location + ivec2(x, y);
            uint index = data[pos.x * ubo.height / ubo.division + pos.y];
            if(index != 0){
                float r = length(particlesIn[id].position - particlesIn[index - 1].position);
                float f = 24 * e /r * (2 * pow(s/r, 12) - pow(s/r, 6));
                if (f>100) f=100;
                F+= f * normalize(particlesIn[id].position - particlesIn[index - 1].position);
                
                
                
            }
        }
    }
    
    a = F / m;
    particlesOut[id].lposition = particlesIn[id].position;
    particlesOut[id].position =  2 * particlesIn[id].position - particlesIn[id].lposition + a/1000;
}
