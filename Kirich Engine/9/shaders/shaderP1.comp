#version 450

struct ParticleType{
    float rmin;
    float e;
    float m;
};

layout (set = 0, binding = 0) uniform ParameterUBO {
    ParticleType particleTypes[2];
    int width;
    int height;
    int particleCount;
    int particleDivision;
} ubo;

struct Particle {
    vec2 position;
    vec2 lposition;
    int type;
};

layout(std430, set = 1, binding = 0) readonly buffer ParticleSSBOIn {
    Particle particlesIn[ ];
};

layout(std430, set = 1, binding = 1) buffer ParticleSSBOOut {
    Particle particlesOut[ ];
};

layout(std430, set = 1, binding = 2) readonly buffer ParticleData {
    int data[ ];
};

int compar(int x1, int y1, int x2, int y2){
    
    if (y1 > y2) 
    	return 1;
    if (y1 < y2)
    	return -1;
    if (x1 > x2)
    	return 1;
    if (x1 < x2)
    	return -1;
    
    return 0;

}

int find(int x, int y){
    int minIndex=0;
    int maxIndex=ubo.particleCount-1;
    while(true){
        if((maxIndex-minIndex)<=1) {
            return minIndex;
        
        }
        int index = int((minIndex + maxIndex) / 2.0);
        if (compar(x, y, data[index*3], data[index*3+1]) > 0){
            minIndex = index;
        }else{
            maxIndex = index;
        }
    }
    return -1;  
}

vec2 calculate(Particle p1, ParticleType pt1, Particle p2, ParticleType pt2){
    float r = length(p1.position - p2.position);
    if(r < 15){
        float rmin = pt1.rmin + pt2.rmin;
        float e = pt1.e * pt2.e;
                
        vec2 f = (12 * e /r * (pow(rmin / r, 12) - pow(rmin / r, 6))) * normalize(p1.position - p2.position);
        if (p2.type==0){
            f-=(p1.position - p1.lposition)*rmin/length(p1.position - p2.position)/100;
        }
        return f;
                
    }
    return vec2(0);
}



layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
void main() 
{
    uint id = gl_GlobalInvocationID.x;
    Particle currentParticle = particlesIn[id];
    ParticleType currentParticleType = ubo.particleTypes[currentParticle.type];
    
    particlesOut[id].lposition = currentParticle.lposition;
    particlesOut[id].position = currentParticle.position;
    particlesOut[id].type = currentParticle.type;

    if (currentParticle.type==0){
        return;
    }

    vec2 F = vec2(0, 0);

    if(false){
        int id1=-1;
        while (id1<ubo.particleCount){
            id1+=1;
            if (id1==id)continue;

            Particle secondParticle = particlesIn[id1];
            ParticleType secondParticleType = ubo.particleTypes[secondParticle.type];

            F += calculate(currentParticle, currentParticleType, secondParticle, secondParticleType);
            
        }
    }
    else{
        for(int y=-1; y<=1; y++){
            int index = find(int(currentParticle.position.x / ubo.particleDivision) - 1, int(currentParticle.position.y / ubo.particleDivision) + y);
            while ((index<ubo.particleCount)){
                if ((int(currentParticle.position.x / ubo.particleDivision) + 1 < data[index*3]) &&
                    (int(currentParticle.position.y / ubo.particleDivision) + y == data[index*3 + 1])) break;
                else if (int(currentParticle.position.y / ubo.particleDivision) + y < data[index*3 + 1]) break;
                else if(int(currentParticle.position.y / ubo.particleDivision) + y > data[index*3 + 1]){
                    index+=1;
                    continue;
                }

                uint id1 = data[index*3+2];
                index+=1;

                if (id1==id)continue;

                Particle secondParticle = particlesIn[id1];
                ParticleType secondParticleType = ubo.particleTypes[secondParticle.type];

                F += calculate(currentParticle, currentParticleType, secondParticle, secondParticleType);
            }
        }
    }

    F += vec2(0,0.01);
    //F-=(currentParticle.position - currentParticle.lposition);
//    if (length(F)>50){
//        F = normalize(F) * 50;
//    }

    vec2 a = F / currentParticleType.m;
    particlesOut[id].lposition = currentParticle.position;
    particlesOut[id].position = 2*currentParticle.position - currentParticle.lposition + a;
    particlesOut[id].type = currentParticle.type;
    
}
